# Web Scan Watcher

Скрипт для автоматизации сканирования веб-приложений с поддержкой авторизации. Создает проект сканирования, запускает его и мониторит валидность авторизации на протяжении всего времени работы.

## Возможности

- Автоматическое создание и запуск проекта сканирования через API
- Периодическая проверка валидности авторизации в целевом приложении
- Автоматическая остановка сканирования при потере авторизации
- Валидация JWT-токенов перед запуском с предупреждением об истечении срока
- Поддержка секретов через переменные окружения (`env::VARIABLE_NAME`)
- Поддержка запуска нескольких экземпляров с разными префиксами окружения

## Требования

- Python 3.10+
- Зависимости из `requirements.txt`

## Установка

```bash
pip install -r requirements.txt
```

## Быстрый старт

1. Скопируйте пример конфигурации:

```bash
cp config.example.yaml config.yaml
```

2. Отредактируйте `config.yaml` под ваши нужды

3. Установите переменные окружения:

```bash
export SF_TOKEN="ваш-api-токен"
export SF_APP_URL="https://sf.example.com"
```

4. Запустите скрипт:

```bash
python scan_watcher.py config.yaml
```

## Конфигурация

### Структура конфигурационного файла

```yaml
project:
  name: "my-web-scan"      # Имя проекта (обязательно)
  one_time: true           # Одноразовое сканирование
  priority: 0              # Приоритет (-1 до 3)

target: "example.com"      # Цель: домен или IP-адрес

webauth:                   # Заголовки авторизации для целевого приложения
  Authorization:
    - "Bearer eyJhbGci..."
  Cookie:
    - "session=abc123"
    - "env::SESSION_TOKEN" # Значение из переменной окружения

monitoring:
  # URL для проверки валидности авторизации. Скрипт отправляет GET-запрос
  # с заголовками из webauth. Если ответ не входит в список разрешённых
  # кодов — сканирование останавливается.
  health_check_url: "https://example.com/api/me"

  # Список HTTP-кодов, которые считаются успешной авторизацией.
  # Любой другой код (401, 403, 500 и т.д.) означает потерю доступа.
  health_check_allowed_http_codes:
    - 200  # OK
    - 204  # No Content (некоторые API возвращают при успешной проверке)

  check_interval_minutes: 5   # Интервал проверки (1-60)
  max_runtime_hours: 24       # Максимальное время работы (до 240)
```

### Параметры проекта (`project`)

| Параметр   | Тип    | По умолчанию | Описание                                                                           |
| ---------- | ------ | ------------ | ---------------------------------------------------------------------------------  |
| `name`     | string | —            | Имя проекта (обязательно)                                                          |
| `one_time` | bool   | `true`       | Одноразовое сканирование. При `true` скрипт завершится после завершения всех задач |
| `priority` | int    | `0`          | Приоритет сканирования от -1 до 3. Чем выше — тем приоритетнее                     |

### Цель сканирования (`target`)

Указывается одна цель — домен или IP-адрес:

```yaml
target: "example.com"
# или
target: "192.168.1.100"
```

### Заголовки авторизации (`webauth`)

Заголовки, которые будут использоваться:

- При сканировании целевого приложения
- При проверке валидности авторизации (health check)

```yaml
webauth:
  Host:
    - "example.com"
  Authorization:
    - "Bearer eyJhbGciOiJIUzI1NiIs..."
  Cookie:
    - "session=abc123; csrf=xyz789"
```

Каждый заголовок может содержать несколько значений

#### Секреты через переменные окружения

Для безопасного хранения токенов используйте префикс `env::`:

```yaml
webauth:
  Authorization:
    - "env::AUTH_TOKEN"  # Будет взято из $AUTH_TOKEN
  Cookie:
    - "env::SESSION_COOKIE"
```

**При использовании `--env-prefix` переменные также получат префикс:**

```bash
# С --env-prefix=RUN1__
# env::AUTH_TOKEN будет искать $RUN1__AUTH_TOKEN
```

### Мониторинг (`monitoring`)

| Параметр                          | Тип       | По умолчанию | Описание                                           |
| --------------------------------- | --------- | ------------ | -------------------------------------------------- |
| `health_check_url`                | string    | —            | URL для проверки авторизации (обязательно)         |
| `health_check_allowed_http_codes` | list[int] | `[200]`      | HTTP-коды, означающие успешную авторизацию         |
| `check_interval_minutes`          | int       | `5`          | Интервал между проверками (1-60 минут)             |
| `max_runtime_hours`               | float     | `24`         | Максимальное время работы (до 240 часов = 10 дней) |

#### Health Check URL

URL, на который будет отправляться GET-запрос с заголовками из `webauth`. Если ответ содержит HTTP-код не из списка `health_check_allowed_http_codes`, сканирование будет остановлено.

Рекомендуется использовать эндпоинт, требующий авторизации, например:

- `/api/me`
- `/api/user/profile`
- `/api/auth/check`

## Переменные окружения

| Переменная   | Описание                                     |
| ------------ | -------------------------------------------- |
| `SF_TOKEN`   | API-токен для авторизации в SF (обязательно) |
| `SF_APP_URL` | Базовый URL API SF (обязательно)             |

При использовании `--env-prefix` переменные должны иметь соответствующий префикс:

```bash
# Для --env-prefix=RUN1__
export RUN1__SF_TOKEN="..."
export RUN1__SF_APP_URL="..."
```

## Аргументы командной строки

```
usage: scan_watcher.py [-h] [--env-prefix ENV_PREFIX] [--force]
                       [--log-level {DEBUG,INFO,WARNING,ERROR}] config

positional arguments:
  config                Путь к YAML/JSON файлу конфигурации

options:
  -h, --help            Показать справку
  --env-prefix PREFIX   Префикс для переменных окружения (например, RUN1__)
  --force, -f           Пропустить подтверждение при предупреждениях о токенах
  --log-level LEVEL     Уровень логирования (по умолчанию: INFO)
```

## Примеры использования

### Базовый запуск

```bash
export SF_TOKEN="eyJhbGci..."
export SF_APP_URL="https://sf.company.com"

python scan_watcher.py config.yaml
```

### Запуск нескольких экземпляров

```bash
# Терминал 1
export RUN1__SF_TOKEN="token1"
export RUN1__SF_APP_URL="https://sf.company.com"
export RUN1__AUTH_TOKEN="Bearer abc..."
python scan_watcher.py config1.yaml --env-prefix=RUN1__

# Терминал 2
export RUN2__SF_TOKEN="token2"
export RUN2__SF_APP_URL="https://sf.company.com"
export RUN2__AUTH_TOKEN="Bearer xyz..."
python scan_watcher.py config2.yaml --env-prefix=RUN2__
```

### Запуск в фоне с nohup

```bash
nohup python scan_watcher.py config.yaml > scan.log 2>&1 &
```

## Коды завершения

| Код | Константа      | Описание                                             |
| --- | -------------- | ---------------------------------------------------- |
| 0   | `SUCCESS`      | Сканирование завершено успешно или graceful shutdown |
| 1   | `AUTH_FAILURE` | Авторизация стала невалидной                         |
| 2   | `CONFIG_ERROR` | Ошибка конфигурации или валидации токенов            |
| 3   | `API_ERROR`    | Ошибка при работе с API                              |

## Валидация JWT-токенов

Скрипт автоматически анализирует JWT-токены в:

- `SF_TOKEN` (API-токен)
- Значениях `webauth` (токены авторизации приложения)

Если токен истекает раньше, чем `max_runtime_hours`, будет показано предупреждение:

```
============================================================
  WARNING: Token Expiration Risk
============================================================

• API token (SF_TOKEN) expires in 12.5 hours, but max_runtime_hours is 24
• Token in webauth.Authorization expires in 8.0 hours

max_runtime_hours is set to 24 hours.

This means the scanner may lose access before the scan completes.
The scan will be stopped when auth check fails, but scan time will be wasted.

Recommendations:
  - Reduce max_runtime_hours to match token lifetime
  - Use longer-lived tokens
============================================================

Continue anyway? [y/N]:
```

Используйте флаг `--force` для автоматического пропуска этого подтверждения.

## Логика работы

1. **Создание проекта**
2. **Запуск сканирования**
3. **Периодический мониторинг и health check**
4. **Остановка сканирования**

## Выключение scan_watcher

При получении сигналов `SIGINT` (Ctrl+C) или `SIGTERM` скрипт прерывает мониторинг и останавливает сканирование проекта, завершаясь с кодом 0.

Обратно включить сканирование проекта можно в ЛК.

Снова включить сканирование с уже использованным конфигом нельзя - нужно поменять название проекта в конфигурации, тогда будет снова создан новый проект, либо в ЛК удалить проект который был создан скриптом.

## Определение завершения сканирования

Для проектов с `one_time: true` сканирование считается завершённым, когда все созданные задачи для сканеров были выполнены.

## Решение возможных проблем

### Ошибка "Environment variable X is not set"

Убедитесь, что переменная экспортирована:

```bash
export SF_TOKEN="..."
# Проверка
echo $SF_TOKEN
```

При использовании `--env-prefix` не забудьте добавить префикс к переменным.

### Health check всегда failing

1. Проверьте, что `health_check_url` доступен и требует авторизации
2. Убедитесь, что заголовки в `webauth` корректны
3. Проверьте список `health_check_allowed_http_codes`
4. Запустите с `--log-level=DEBUG` для подробного вывода

### Токен истёк во время сканирования

Скрипт автоматически остановит сканирование при первой неуспешной проверке авторизации. Для минимизации потерь:

- Используйте токены с большим сроком жизни
- Уменьшите `max_runtime_hours` до времени жизни токена
- Уменьшите `check_interval_minutes` для более быстрого обнаружения
